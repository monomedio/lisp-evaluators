#lang racket

; CSC324 — 2022W — Assignment 2 — Unifier Design and Testing

; • A “First-Order Term Unifier”

; Task: explore the language of first-order terms and a unification algorithhm,
; then implement that algorithm in A2.unify.rkt.

; The unifier then supports the type inference in A2.test.rkt by solving type
; constraints generated by A2.infer.rkt.

(require "A2.unify.rkt" rackunit)


; · Language of First-Order Terms

; A (first-order) “term” is one of:
;   (<functor> <argument-term> ...)  [“compound term”]
;   <constant>                       [“constant term”]
;   <variable>                       [“variable term”]

; A non-compound term is called “atomic”.

; · Representation of Terms

; Compound terms are represented by lists, where the first element is then
; by definition the functor and the rest of the elements are terms.

; Atomic terms are represented by non-lists.
; Which atomic terms are variable terms will depend on context.

; For example, if variables are (represented by) upper-case symbols then ...
#;'(-> int T)
; ... (represents) a compound term with functor ->, a constant term int for its
; first argument, and a variable term T for its second argument.


; · Looking Ahead — An Example

; We will put pairs of terms in a list and ask whether the pairs of terms can
; be made identical by some “setting/assignment/instantiation” of the variables.

; Let upper-case identifiers be variables.
; Can R and (-> U S), T and (-> V S), (-> int (-> int int)) and (-> int T),
; and U and V, be made equal by setting R, S, T, U, and V appropriately?
(define equations '((R (-> U S))
                    (T (-> V S))
                    ((-> int (-> int int)) (-> int T))
                    (U V)))

; There is an iterative solution process that looks at the first equation and
; produces a new list of equations and possibly an assignment for one of the
; remaining variables.
  
; R is (-> U S), and now solve the list of equations ...
#;((T (-> V S))
   ((-> int (-> int int)) (-> int T))
   (U V))
  
; T is (-> V S), solve ...
#;(((-> int (-> int int)) (-> int (-> V S)))
   (U V))
  
; Solve ...
#;((int int)
   ((-> int int) (-> V S))
   (U V))
  
; Solve ...
#;(((-> int int) (-> V S))
   (U V))
  
; Solve ...
#;((int V)
   (int S)
   (U V))
  
; Solve ...
#;((V int)
   (int S)
   (U V))
  
; V is int, solve ...
#;((int S)
   (U int))
  
; Solve ...
#;((S int)
   (U int))
  
; S is int, solve ...
#;((U int))
  
; U is int, solve ...
#;()

; Understand what was done at each step, and then compare that with the general
; description of the algorithm later in this file.

; The resulting “substitution” is to replace (in order!):
;   R with (-> U S)
;   T with (-> V S)
;   V with int
;   S with int
;   U with int

; The function mgu will take a predicate to determine variables, and a list of
; equations, and try to produce a substitution function that solves it.

; A variable predicate: is t a symbol starting with an upper-case character?
(define (capital? t)
  (and (symbol? t) (char-upper-case? (string-ref (symbol->string t) 0))))

; Try to solve the equations (or produce #f).
(define σ (mgu capital? equations))

; The result (if not #f) is a unary function for the solution's substitution.
#;(check-equal? (map σ '(R S T U V))
                '((-> int int) int (-> int int) int int))
#;(check-equal? (map σ (map first equations))
                '((-> int int) (-> int int) (-> int (-> int int)) int))
#;(check-equal? (map σ (map first equations))
                (map σ (map second equations)))


; · Occurrence, Substitution, and Equations

; A term t0 “occurs” inside term t iff t is t0 or t is a compound term and
; t0 occurs inside one of t's (argument) terms.

; A “substitution” σ is a unary function from variables to terms.
; A substitution σ can be considered more generally as a function on all terms:
; let σ(t) = t with each occurrence of variable v in t replaced by σ(v).

; An “equation” t1 ≡ t2 is the claim that there exists a substitution σ so that
; σ(t1) = σ(t2). If the claim is true, such a substitution is called a “unifier”
; of t1 and t2.

; An equation is represented by a list of two terms.


; · Unification and an Algorithm for it

; “Unification” takes a list of equations and tries to find a substitution that
; unifies each equation in the most general way possible. Such a substitution
; (if it exists) is known as the “most general unifier” (mgu) of the equations.

; For an empty list of equations the mgu is the identity function.

; Otherwise we have a list of equations t ≡ t′, t1 ≡ t1′, t2 ≡ t2′, etc.

; A necessary (but not sufficient) for an mgu to exist is then: t and t′ are
; both the same constant, or both are compound terms with the same functor and
; number of argument terms, or at least one is a variable.

; Suppose t and t′ are equal. The mgu is then the mgu (if it exists) of the
; other equations: t1 ≡ t1′, t2 ≡ t2′, etc.

; Suppose t and t′ are compound terms (f a1 ...) and (f a1′ ...) with the
; same number of arguments. The mgu is then the mgu (if it exists) of the
; equations where t ≡ t′ is replaced with equations between all the argument
; terms:  a1 ≡ a1′, ...,  t1 ≡ t1′, t2 ≡ t2′, etc.

; Suppose t is a variable (and t′ isn't t).
; Let σ be the substitution that maps t to t′.
; The mgu then exists iff t doesn't occur in t′, and the equations
; σ(t1) ≡ σ(t1′), σ(t2) ≡ σ(t2′), etc have an mgu σ′.
; The mgu is then σ′ ∘ σ.

; Suppose none of the the previous apply and t′ is a variable.
; The mgu is then the mgu (if it exists) of the equations with t and t′
; swapped in the first equation t′ ≡ t, t1 ≡ t1′, t2 ≡ t2′, etc.
